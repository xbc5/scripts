#!/bin/env python3
from subprocess import check_call, check_output, Popen, PIPE, DEVNULL,CalledProcessError
from os.path import dirname, join, isfile
from os import chdir, getcwd, environ, makedirs, listdir
from sys import exit
import argparse
import json
from shutil import which

# TODO: use the "yes" (Linux) command if args.assumeyes is used: `yes | npx ...`
# TODO: possibly call shell functions to start projects, so that users can do easy plugins

VALID_STACKS = ("svelte", "storybook")


def valid_stacks_string():
    return ', '.join(VALID_STACKS)


def dependency_checks():
    deps = ("npm", "degit", "node", "npx", "fd", "nohup", "git")
    missing = []

    for dep in deps:
        if not which(dep):
            missing.append(dep)
    if missing:
        msg = f"You need to install the following dependencies first: {', '.join(missing)}"
        print(msg)  # not swallowed by catch statement, includes dependencies
        raise FileNotFoundError(msg)


def environment_check():
    try:
        environ["DEV_PROJECTS"]
        environ["DEV_PRACTICE"]
        environ["IDE"]
    except KeyError:
        raise EnvironmentError("Evironment variables not set")


def get_root(proj_type="real"):
    return environ["DEV_PROJECTS"] if proj_type == "real" else environ["DEV_PRACTICE"]


def get_package_json(target):
    pj = join(target, "package.json")
    with open(pj, 'r') as f:
        j = json.load(f)
    return j


def get_ide():
    return environ['IDE']


def get_path(proj_type, parent, name):
    return join(get_root(proj_type), parent, name)


def make_dirs(target):
    try:
        makedirs(target)
    except FileExistsError:
        print(f"the target directory already exists: {target}")
        exit(3)


def init_svelte(target, ts=True):
    make_dirs(target)
    chdir(target)
    check_call(["npx", "degit", "sveltejs/template", "."])

    if ts:
        check_call(["node", "scripts/setupTypeScript.js"])

    check_call(["npm", "install"])


def start_svelte(target, mode="dev"):
    assert mode in ["dev", "build"]
    chdir(target)
    check_call(["npm", "run", "dev"])


def pick_proj():
    # FIXME: find a better solution than --exclude, because you can't keep appending to this for every project type
    try:
        r = check_output(
            f"fd --type d --hidden --no-ignore --exclude '.git/*' --exclude 'node_modules' '.git$' {get_root('real')} {get_root('practice')} --exec echo {{//}} | fzf --height 10",
            shell=True).decode("utf-8").rsplit()
    except CalledProcessError as e:
        r = {
            1: "",  # no fuzzy match
            130: "",  # cancelled (ctrl+c)
        }.get(e.returncode, False)
        if r is False:
            raise e

    return r[0] if r else ""


def is_svelte(target):
    try:
        j = get_package_json(target)
    except FileNotFoundError:
        return False

    try:
        j['devDependencies']['svelte']
    except KeyError:
        return False

    return "svelte"


def guess_stack(target):
    package_json = join(target, "package.json")
    for predicate in [is_svelte]:
        p = predicate(target)
        if p:
            return p
    raise ValueError(f"Cannot guess project type for {target}")


def get_storybook_addons():
    return ['@storybook/addon-controls',
            'storybook-dark-mode', ]


def init_storybook(target):
    chdir(target)
    check_call(["npx", "sb", "init"])
    check_call(["npm", "install", "--save-dev"] + get_storybook_addons())


def is_storybook(target):
    try:
        j = get_package_json(target)
    except FileNotFoundError:
        return False

    try:
        j['scripts']['storybook']
    except KeyError:
        return False

    return "storybook"


def start_storybook(target):
    chdir(target)
    if not is_storybook(target):
        print(f"This is not a Storybook project: {target}")
        exit(19)
    check_call(["npm", "run", "storybook"])


def start_ide(target):
    Popen(["nohup", get_ide(), target], stdout=DEVNULL, stderr=DEVNULL)


def start(target, stack):
    """
    The entry point for starting a runtime. Specify a stack to determine
    the start script.

    :stack e.g. svelte, react
    """
    {
        "svelte": start_svelte,
        "storybook": start_storybook
    }[stack](target)


def init(target, stack):
    """
    The entry point for initialising a project.
    """
    {
        "svelte": init_svelte,
        "storybook": init_storybook
    }[stack](target)


def handle_start(args):
    target = pick_proj()

    if not target:
        print("No target specified")
        exit(21)

    if args.storybook:
        stack = "storybook"
    else:
        stack = args.stack if args.stack else guess_stack(target)

    if not stack:
        print(
            f"Unable to determine stack for {target}, provide one explicitly (--stack) from: {valid_stacks_string()}")
        exit(21)

    if not args.noide:  # if ide
        start_ide(target)

    start(target, stack)


def handle_open(args):
    target = pick_proj()

    if not target:
        print("No target specified")
        exit(21)

    start_ide(target)

    if not args.start:
        return

    try:
        if args.stack:
            stack = args.stack
        else:
            stack = "storybook" if args.storybook else guess_stack(target)
    except ValueError:
        print(
            f"Unable to determine stack for {target}, provide one explicitly (--stack) from: {valid_stacks_string()}")
        exit(21)

    start(target, stack)


def get_stack(args):
    """
    If stack not set, use group if it matches a valid stack. Then
    validate that a proper stack is set.
    """
    if not args.stack:
        stack = args.group if args.group in VALID_STACKS else None
    else:
        stack = args.stack

    if not stack or stack not in VALID_STACKS:
        raise ValueError(
            f"stack is invalid, it should be one of {valid_stacks_string()}")

    return stack


def git_init(target, initial_commit):
    chdir(target)
    check_output(["git", "init"])
    if initial_commit:
        check_output(["git", "add", "*", ".gitignore"])
        check_output(["git", "commit", "--all", "--message", "init"])


def handle_init(args):
    try:
        stack = get_stack(args)
    except ValueError:
        print(
            f"You must set either --stack or --group to match a supported stack: {valid_stacks_string()}.")
        exit(5)

    if not args.name:
        print(f"You must provide a project name.")
        exit(11)

    proj_type = "practice" if args.practice else "real"
    target = get_path(proj_type, args.group, args.name)  # project root

    print(f"Initialising a {proj_type} {stack} project in {target}..")
    if not args.assumeyes and input(f"Continue? [y/N]: ").upper() != "Y":
        print("No changes made.")
        exit(0)

    init(target, stack)
    # print(f"init(target={target}, stack={stack})")
    if args.storybook:
        init(target, "storybook")
        # print(f"start(target={target}, stack='storybook'")

    if not args.nogit:  # if git
        git_init(target, True)

    if args.ide:
        start_ide(target)

    if args.start:
        if args.storybook:
            start(target, "storybook")
        else:
            start(target, stack)
        # print(f"target={target}, start(stack={stack})")


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    init = subparsers.add_parser("init", help="initialise a project")
    init.add_argument("--assumeyes", default=False, action='store_true',
                      help="don't prompt; answer yes to everything")
    init.add_argument("--practice", default=False, action='store_true',
                      help=f"create the project in {get_root('practice')}")
    init.add_argument("--start", default=False, action='store_true',
                      help="start the chosen stack after init")
    init.add_argument("--stack", choices=VALID_STACKS, default=None, action='store', dest="stack",
                      type=str, help="the desired stack. You can omit it if '--group' is a valid stack")
    init.add_argument("--group", default="ungrouped", action='store', dest="group",
                      type=str, help="a subdirectory to store the project in (defaults to 'ungrouped')")
    init.add_argument("--storybook", default=False, action='store_true',
                      help="initialise Storybook with the stack")
    init.add_argument("--nogit", default=False, action='store_true',
                      help="don't initialise git; don't make an initial commit")
    init.add_argument("--ide", default=False,
                      action='store_true', help="start your $IDE")
    init.add_argument("name", type=str, help="the name of the project folder")
    init.set_defaults(func=handle_init)

    start = subparsers.add_parser("start", help="start a project runtime")
    start.add_argument("--storybook", default=False, action='store_true',
                       help="run the Storybook runtime instead of any others")
    start.add_argument("--name", type=str,
                       help="the name of the target project folder. If omitted an fzf menu is invoked")
    start.add_argument("--stack", choices=VALID_STACKS, default=None, action='store', dest="stack",
                       type=str, help="the target stack; if omitted, it's guessed")
    start.add_argument("--noide", default=False,
                       action='store_true', help="don't start your $IDE")
    start.set_defaults(func=handle_start)

    opn = subparsers.add_parser("open", help="open a project in your $IDE")
    opn.add_argument("--storybook", default=False, action='store_true',
                     help="run the storybook runtime")
    opn.add_argument("--start", default=False, action='store_true',
                     help="start the default runtime")
    opn.add_argument("--stack", choices=VALID_STACKS, default=None, action='store', dest="stack",
                     type=str, help="the target stack; if omitted, it's guessed")
    opn.set_defaults(func=handle_open)

    args = parser.parse_args()
    try:
        args.func(args)
    except AttributeError as e:
        # args.func doesn't exist when parent parser receives no args (init/start)
        if not hasattr(args, 'func'):
            print("You must provide a command: e.g. init, start...\n")
            parser.parse_args(["-h"])  # show help
            exit(17)
        raise e


if __name__ == '__main__':
    try:
        dependency_checks()
    except FileNotFoundError:
        exit(14)

    try:
        environment_check()
    except EnvironmentError:
        print("You must set the DEV_PROJECTS, DEV_PRACTICE, and IDE environment variables first.")
        exit(1)

    try:
        main()
    except KeyboardInterrupt:
        exit(0)
